# 7.함께 모으기

> 코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다. - 에릭 에반스

- 객체지향 설계를 바라보면 3가지 상호적인 관점
  - 동일한 클래스를 세 가지 다른 방향에서 바라보는 것
- **개념관점(Conceptual Perspective)**
  - 사용자가 도메인을 바라보는 관점
  - 실제 도메인 규칙과 제약을 최대한 유사하게 반영하는게 핵심
- **명세관점(Specification Perspective)**
  - 개발자가 객체의 책임을 바라보는 관점
  - 객체의 인터페이스를 바라보는 관점
  - 객체가 협력을 위해 '무엇'을 할 수 있는가에 초점
  - 메시지를 선택하고 메시지를 수신할 객체를 선택하기

- **구현 관점(Implementation Perspective)**
  - 객체들이 책임을 수행하는 데 필요한 코드를 바라보는 관점
  - 객체가 책임을 '어떻게' 수행할 것 인가에 초점
  - 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가하는 과정
- 클래스를 보고 이 3가지 관점이 보이면 좋은 클래스


## 1.커피 전문점 도메인

- 목표
  - 첫 번째: 도메인 모델 만들기부터 최종 코드 구현까지 이해
  - 두 번째: 구현 클래스를 3가지 관점에서 바라보는 것이 무엇을 의미하는지 설명하기


### 1.1 커피 주문

- 예시
- 커피 전문점에서 커피를 주문하는 과정을 객체의 협력 관계로 구현해보기

### 1.2 커피 전문점이라는 세상

<img width="615" alt="image" src="https://user-images.githubusercontent.com/49191949/172807988-85a6f01f-e227-4bd0-94a9-c670a1303c92.png">


- 커피 전문점이라는 세상(=도메인)에서 객체가 될만한 것들 찾아보기
  - 손님, 메뉴판, 메뉴 항목, 바리스타, 커피
  - 객체가 될 만한 것들은 경계를 가지고 있는 것이다.

- 객체를 찾아봤으니 객체들 간의 관계를 살펴보기
  - 손님-메뉴판
    - 손님은 메뉴판에서 커피를 선택할 수 있어야 한다.
    - 따라서 손님은 메뉴판을 '알아야'함. 따라서 관계가 존재한다.
  - 손님-바리스타
    - 손님은 바리스타에게 '주문'을 해야함. 따라서 관계가 존재한다.
- 참고로 우리의 뇌는 동적인 객체를 쉽게 이해할 수 있을만큼 똑똑하지 않다.
  - 따라서, 도메인 모델을 이용해서 이렇게 동적인 객체를 정적인 타입으로 추상화하여 복잡성을 낮춘다.
- 상태와 무관하게 동일하게 행동하는 객체들은 동일한 타입으로 분류된다.
  - 손님 객체는 '손님 타입'의 인스턴스로 볼 수 있다.


<img width="351" alt="image" src="https://user-images.githubusercontent.com/49191949/172810078-1e1ba75e-135f-4861-9578-d19a2e49010a.png">

- 하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성되어 있다.
- 두 객체는 포함관계
- 포함관계(합성관계, composition): 선에 그려진 속이 꽉찬 마름모 쪽 객체가 다른 객체를 포함하는 관계.

<img width="351" alt="image" src="https://user-images.githubusercontent.com/49191949/172810744-cf097c50-1e6b-4847-8c10-9ca26f41f970.png">

- 메뉴판과 손님은 서로 알고 있는 관계
- 연관관계(association)
- 실선으로 표현

<img width="375" alt="image" src="https://user-images.githubusercontent.com/49191949/172811056-3eec5e4b-a917-4fd5-a1a6-edc96d692bdf.png">

- 최종 커피전문점 도메인 모델
- 바리스타는 커피를 제조하니 커피 타입(객체)와 연관관계
- 메뉴판과 커피는 바리스타의 일부가 아니므로 포함관계가 아니다.

---
- 지금까지 한 것
1. 도메인 객체 생각하기
2. 도메인 객체 관계 생각하기
3. 도메인 모델 완성

- 앞으로 해야할 것
  - 도메인 모델을 기반으로 소프트웨어로 옮기기
  - 협력을 설계하기 = 적절한 객체에게 적절한 책임 할당하기

- 참고
  - 도메인 모델을 만드는 과정에서 중요한 것은 어떤 객체가 있고, 어떤 관계를 가지느냐가 아니라 2가지를 파악함으로써 도메인을 이해하는 것이다



## 2.설계하고 구현하기


### 2.1 커피를 주문하기 위한 협력 찾기

- 객체지향적 설계하기 첫 번째 목표: 훌륭한 협력 설계하기
- 훌륭한 협력 설계하는 방법
  - 메시지가 객체를 선택하게 해야 한다. (반대주의)
  - 1.메시지 선택하기 2. 이 메세지를 수신할 적절한 객체 선택하기
- 현재 협력: 커피를 주문하기
- 1.메세지 찾기
- 첫 번째 메세지: '커피를 주문하라'

  <img width="312" alt="image" src="https://user-images.githubusercontent.com/49191949/172813001-4fb06b89-c2bf-48d5-aa15-76dfe25f1672.png">
2. 메시지를 수신받을 적절한 객체 찾기
   - 어디서 찾지 --> 앞에서 만들어놓은 도메인 모델안 객체(타입)
   - 손님

<img width="345" alt="image" src="https://user-images.githubusercontent.com/49191949/172813468-2ffc8b8d-f41c-4ed6-8f58-acb8c872e500.png">

- 이제 메시지(요청)을 받은 손님 객체는 '커피를 주문하라'라는 책임이 생김
- 위 책임에서 손님이 스스로 할 수 없는 일은 다른 객체한테 요청을 해야됨
  - 손님은 메뉴 항목에 대해 알지 못함, 메뉴 항목은 손님의 일부가 아니고 메뉴판의 일부
  - 따라서 손님은 자신이 선택한 메뉴 항목을 누군가가 제공해 줄 것을 요청한다.
  - = '메뉴 항목을 찾아라'라는 새로운 메시지 등장

<img width="437" alt="image" src="https://user-images.githubusercontent.com/49191949/172814277-f335230e-80e7-40ad-9007-4de62d6d458e.png">

- 두 번째 메시지('메뉴항목을 찾아라')에 대한 책임을 누구에게 할당할까? --> 도메인 모델을 보고 메뉴판 객체 선택
  - 이유: 메뉴 항목을 가장 잘 알고 있는 객체는 메뉴판 객체

<img width="470" alt="image" src="https://user-images.githubusercontent.com/49191949/172815018-2f37201e-94ce-41bf-a612-2a7c30fc7ee2.png">

- 손님은 이제 자신이 주문할 메뉴항목을 얻음 이제 커피를 제조해달라고 요청할 수 있음 (메시지 선택)
- 손님은 스스로 커피를 만들 수 없으니 다른 객체한테 요청해야됨 --> 바리스타  (메시지 받을 객체 선택)

<img width="431" alt="image" src="https://user-images.githubusercontent.com/49191949/172815463-337beec5-9da8-47dc-85b4-1867d69fce00.png">

- 바리스타는 커피를 제조하는 데 모든 정보를 알고 있음
- 커피 만들기 위한 지식 = 바리스타 상태
- 커피를 만드는 기술 = 바리스타 행동

<img width="412" alt="image" src="https://user-images.githubusercontent.com/49191949/172815931-b454d54e-ce03-42c3-9fef-85450d9c8036.png">

- 커피 주문을 위한 협력은 바리스타가 새로운 커피를 만드는 것으로 끝이남
- 협력에 필요한 객체의 종류와 책임, 메시지를 대략적으로 만들었음

- 앞으로 해야할 일
  - 메시지를 다듬어서 각 객체의 인터페이스를 구현 가능할 정도로 상세히 정제하기


### 2.2 인터페이스 정리하기
- 객체가 수신한 메시지가 객체의 인터페이스를 결정한다.
- 메시지가 객체를 선택하고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들임

<img width="473" alt="image" src="https://user-images.githubusercontent.com/49191949/172816761-a5d4f262-f4ca-46a6-87c9-040a49d17f0f.png">

- 객체는 동적이지만 구현은 동적인 타입을 이용해서 이뤄진다.

### 2.3 구현하기

- 만든 오퍼레이션(연산)을 메서드로 구현하기
- 먼저 Customer 협력 살펴보기
  - Customer --> Menu에게 '메뉴 항목 찾아라' 요청
- 문제: Customer가 Menu 객체와 Barista 객체에 어떻게 접근하지?
- 객체가 다른 객체에게 메시지를 전송하려면 해당 객체에 대한 참조가 필요함
  - 메서드 인자로 참조들 전달하는 방법으로 참조문제 해결
  - 그리고 구현하기
- 중요한점: 구현 도중에 객체의 인터페이스가 변경될 수 있다는 점

<img width="735" alt="image" src="https://user-images.githubusercontent.com/49191949/172818201-83fdba45-c6ec-413f-b24b-e67d844c6323.png">

- Menu 구현하기

<img width="658" alt="image" src="https://user-images.githubusercontent.com/49191949/172818504-c3c1d4a7-7d82-4e02-829c-0d8d78c549ff.png">

- MenuItem 목록을 Menu의 속성으로 포함시킨 결정 역시 클래스 구현 도중에 변경되었다는 것 사실 주목
- 가장 훌륭한 방법은 인터페이스를 정하는 단계에서 객체가 어떤 속성을 가지는지 또 그 속성이 어떤 자료구조로 구현되는지 고려하지 않는것
- 객체가 어떤 책임을 수행해야 하는지를 결정한 후 책임을 수행하는 데 필요한 객체의 속성을 결정해라


<img width="564" alt="image" src="https://user-images.githubusercontent.com/49191949/172818926-5e961175-a1f2-47b5-a53e-06b5447b849b.png">

<img width="437" alt="image" src="https://user-images.githubusercontent.com/49191949/172819049-07f5ce92-836b-4bf1-bbe5-091038e687da.png">

<img width="507" alt="image" src="https://user-images.githubusercontent.com/49191949/172819105-9cd8c2f2-c24f-4366-aa6c-9f63f8b3e019.png">

<img width="769" alt="image" src="https://user-images.githubusercontent.com/49191949/172819179-9ccc92c1-8749-4239-bf74-0cb4fa0a9e8d.png">


## 3.코드와 세 가지 관점


### 3.1 코드는 세 가지 관점을 모두 제공해야 한다.
- 소프트웨어 클래스와 도메인 클래스 사이의 간격에 좁을수록 기능 변경하기 위해 소비되는 비용을 줄일 수 있음
- 

### 3.2 도메인 개념을 참조하는 이유
- 객체를 선택할 때 참조할 수 있음
- 도메인을 참조해야 변화에 쉽게 대응할 수 있음

### 3.3 인터페이스와 구현을 분리하라
- 명세 관점 - 클래스의 안정적인 측면
- 구현 관점 - 클래스의 불안정한 측면
- 훌륭한 설계를 결정하는 것은 결국 명세 관점인 인터페이스다.

