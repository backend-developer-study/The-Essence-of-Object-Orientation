# 07_함께 모으기

- 마틴 파울러의 객체지향 설계 안에 존재하는 세 가지 연관된 관점

  1. 개념 관점(Conceptual Perspective)

     - 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현

       - 도메인 : 사용자들이 관심을 가지고 있는 특정 분야나 주제

       - 도메인 모델 : 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델

     - 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.
     - 사용자가 도메인을 바라보는 관점을 반영 -> 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심

  2. 명세 관점(Specification Perspective)

     - 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 이동됨
     - 도메인이 단지 개념이 아닌 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞춤
     - 객체의 인터페이스를 중심으로 본다.
     - 인터페이스와 구현을 분리하는 것이 객체지향 설계로 가는 기본적인 원칙이다.

  3. 구현 관점(Implementation Perspective)

     - 프로그래머에게 가장 익숙한 관점으로 실제 코드와 연관돼 있다.

     - 구현 관점의 초점은 코드를 작성하는 것

- 개념 관점, 명세 관점, 구현 관점의 순서대로 소프트웨어를 개발하는 것은 X
  - **동일한 클래스를 세 가지 다른 방향으로 바라보는 것**을 의미한다.
- 세 가지 관점에서 바라본 클래스
  - 개념 관점(도메인 관점) : 은유하는 개념을 반영
  - 명세 관점 : 공용 인터페이스를 반영
  - 구현 관점 : 속성과 메서드를 반영
- 이번 장의 목표 📌
  - 도메인 모델에서 시작해 최종 코드까지의 구현과정을 따라가기.
  - 구현 클래스를 개념 관점, 명세 관점, 구현 관점에서 바라본다는 것의 의미를 파악하기.

------

### 커피 전문점 도메인

#### 커피 주문

- 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현하기

#### 커피 전문점이라는 세상

- 커피 전문점을 구성하는 객체
  - 손님
  - 메뉴판
  - 메뉴 항목
  - 커피
  - 바리스타
- 커피 전문점을 구성하는 타입
  - 손님
  - 메뉴판
  - 메뉴 항목
  - 바리스타
  - 커피
- 메뉴판 타입과 메뉴 항목 타입의 관계
  - 포함(containment) 또는 합성(composition) 관계
- 손님, 메뉴판, 바리스타, 커피 사이의 관계
  - 연관(association) 관계 : 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 하는 경우

------

### 설계하고 구현하기

#### 커피를 주문하기 위한 협력 찾기

- 객체 지향 설계의 목표
  - **훌륭한 협력을 설계하기 -> 훌륭한 객체를 설계하기 (O)**
  - 훌륭한 객체를 설계하기 -> 훌륭한 협력을 설계하기 (X)
- 협력을 설계하기
  - **메시지가 객체를 선택하기 (O)**
    - 메시지를 선택 -> 메시지를 수신하는 객체를 선택
  - 객체가 메시지를 선택하기 (X)
- 커피를 주문하는 과정을 메시지를 중심으로 설계하기.
  - 협력을 시작하는 첫 번째 메시지 : 커피를 주문하라.
  - '커피를 주문하라'라는 메시지를 수신하는 객체는? (어떤 객체가 커피를 주문할 책임을 지는가)
    -  손님 타입의 인스턴스

  - 손님은 어떤 커피를 주문해야 할지 선택해야 한다.
    - 손님은 커피 종류를 알지 못하니까 해당 정보를 다른 객체에게 요청해야 한다.
    - 해당 정보를 요청하기 위해 '메뉴 항목을 찾아라'라는 새로운 메시지가 등장한다.

  - 메뉴 항목을 가장 잘 아는 객체인 메뉴판에게 손님이 해당 메시지를 전달하면 메뉴 항목을 반환한다.
  - 손님은 메뉴 항목에 대한 정보를 얻었으니 메뉴 항목에 맞는 커피 제조를 요청할 수 있다.
  - 바리스타는 커피를 제조하는 데 필요한 모든 정보를 알고 있다.
    -  손님이 바리스타에게 메뉴 항목의 커피를 제조해줄 것을 요청한다.
    - 바리스타는 요청된 메시지를 확인해서 커피를 제조하고 손님에게 반환한다.


#### 인터페이스 정리하기

- 손님 인터페이스
  - '커피를 주문하라' 오퍼레이션
- 메뉴판 인터페이스
  - '메뉴 항목을 찾아라' 오퍼레이션
- 바리스타 인터페이스
  - '커피를 제조하라' 오퍼레이션
- 커피 인터페이스
  - '커피를 생성하라' 오퍼레이션
- 객체의 타입을 구현하는 일반적인 방법 -> 클래스를 이용하기
  - 위의 설계를 코드로 구현하면 다음과 같다.


```java
class Customer {
    public void order(String menuName) {}
}

class MenuItem {
}

class Menu {
    public MenuItem choose(String name) {}
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {}
}

class Coffee {
    public Coffee(MenuItem menuItem) {}
}
```

#### 구현하기

- 오퍼레이션는 메서드로 구현한다.
- 구현 도중에 객체의 인터페이스가 변경될 수 있다.
- 객체가 다른 객체에게 메시지를 전송하기 위해서는 먼저 객체에 대한 참조를 얻어야 한다.
  - 객체 참조를 얻는 다양한 방법 중 메서드의 인자로 다른 객체를 전달받는 방법을 이용한다.


```java
class Customer {
    public void order(String menuName, Menu menu, Barista barista) {
       MenuItem menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffee(menuItem);
        ...
    }
}

class MenuItem {
    private String name;
    private int price;
    
    public MenuItem(String name, int price) {
        this.name = name;
        this.price = price;
    }
    
    public int cost() {
        return price;
    }
    
    public String getName() {
        return name;
    }
}

class Menu {
    private List<MenuItem> items;
    
    public Menu(List<MenuItem> items) {
        this.items = items;
    }
    
    public MenuItem choose(String name) {
    for (MenuItem each : items) {
        if (each.getName().equals(name)) {
            return each;
        }
    }    
    return null;
	}
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {
        Coffee coffee = new Coffee(menuItem);
        return coffee;
    }
}

class Coffee {
    private String name;
    private int price;
    
    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.cost();
    }
}
```

- 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라.
- 머릿속에 객체의 협력 구조가 번뜩인다면 바로 코드로 구현해라.
- 설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라.
- TDD를 통해 코드를 구현하는 사람들의 작업이 바로 이것이다.

------

### 코드와 세 가지 관점

#### 코드는 세 가지 관점을 모두 제공해야 한다

1. 개념 관점
   - 클래스들을 자세히 살펴보면 도메인을 구성하는 중요한 개념과 관계를 반영한다는 것을 알 수 있다.
   - 클래스가 도메인 개념의 특성을 최대한 수용하면 관리하기 쉽고 유지보수성을 향상시킬 수 있다.
2. 명세 관점
   - 클래스의 인터페이스를 중심으로 바라보는 관점
   - 공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분
     - 인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에 영향을 준다.
     - 그래서 객체의 인터페이스는 수정하기 어렵다.
     - 최대한 변화에 안정적인 인터페이스를 만들기 위해서 인터페이스에 구현과 관련된 세부 사항이 드러나지 않도록 한다.
3. 구현 관점
   - 클래스의 내부 구현을 중심으로 바라보는 관점
   - 메서드의 구현과 속성의 변경을 원칙적으로 외부의 객체에 영향을 주어서는 안 된다.
     - 메서드와 속성이 철저하게 클래스의 내부로 캡슐화돼야 한다.

- 훌륭한 객체지향 프로그래머는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있어야 한다.

#### 도메인 개념을 참조하는 이유

- 메세지를 수신할 객체를 어떻게 선택할 것 인가?
  - 도메인 개념 중에서 가장 적절한 것을 선택하기.
    - 이렇게 선택된 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.
- 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

#### 인터페이스와 구현을 분리하라

- 흘륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스다.
- 명세 관점이 설계를 주도한다면 설계의 품질이 향상될 수 있다.
- 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다.
- **인터페이스와 구현을 분리하라!** ⭐⭐⭐
