# 5.책임과 메시지

- 명확한 역할과 책임이 없어 간질을 앓는 학생을 도와주지 않았던 이야기
- 교훈: 명확한 책임과 역할을 가지고 협력에 참여해야 한다.
- 훌륭한 객체 지향 세계에서는 객체들의 역할과 책임이 명확하고 상호 협력한다.

## 1.자율적인 책임


### 1.1 설계의 품질을 좌우하는 책임

- 협력의 기본 단위는 **자율적인** 객체
- 자율적이란 스스로 정한 규칙에 따라 판단하고 행동하는 것.
- 자율적인 객체: 스스로 정한 원칙과 의지에 따라 맡은 책임을 수행하는 객체
- 책임이란 요청을 처리하기 위해 객체가 수행하는 행동(메서드)
- **적절한 책임**을 **적절한 객체**에 할당해야 자율적인 객체가 되고 설계의 품질이 올라간다.


### 1.2 자신의 의지에 따라 증언할 수 있는 자유

- 요청 = 수신자의 책임
- 1.왕 --> 모자장수: '증언하' = 모자장수(수신자)의 책임
  - 왕의 입장에서 모자 장수가 어떤 방법으로 증언하는지는 중요X
  - 적절한 추상성 + 적절한 명확성 = 자율적 O
- 2.왕 --> 모자장수: 1.목격장소 2.떠오르는 기억 재구성 3. 말로 간결하게
  - 모자장수의 책임이 너무 커짐 --> 모자장수의 자율성 훼손.
  - 결국 모자장수는 자율적 책임을 질 수 없다.
  - 왕의 요청에 의존적하게 된다.
  - 낮은 추상성 + 너무 구체적인 명확성 = 자율적 X
- 객체에 할당되는 책임의 수준 역시 자율적이어야 한다.

### 1.3 너무 추상적인 책임

- 그렇다고 지나치게 추상적인 요청(책임)인 것도 좋지 않다.
- 왕 --> 모자장수: 설명해라
- 높은 추상성 + 낮은 명확성 = 자율적 X
- 책임은 협력은 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.
- 어떤 책임이 자율적인지 판단하는 기준은 문맥에 따라 다르다.
  - 다른 상황에서는 '설명하라'가 적절할 수 있다.

### 1.4 '어떻게'가 아니라 '무엇'을

- **자율적인 책임**의 특징은 객체가 어떻게(how) 해야 하는가가 아니라 **무엇**(what)을 해야 하는가를 설명한다.
- '증언하라'라는 책임은 모자 장수에게 '무엇'을 해야하는 지 결정해준다.
- '목격했던 장면을 떠올리고', '떠오르는 기억을 시간 순서대로 재구성'한 후 '말로 간결하게'라는 책임은 '어떻게'해야 하는지를 설명한다.

### 1.5 책임을 자극하는 메세지

- 객체가 자신에게 할당된 **책임을 수행하도록 만드는 것**은 외부에서 전달되는 **요청**에서 시작된다.
- 객체가 다른 객체에게 접근하는 유일한 방법은 **요청**이다.
- 요청 = 메시지


## 2.메시지와 메서드


### 2.1 메시지

- 객체의 행동을 유발하는 행위를 '**메시지-전송**'이라한다.
- '증언하라' = 메시지 이름(message name)
- 추가정보는 메세지 인자를 통해 제공한다. ex)증언하라(어제,왕국)
- 메세지 전송 = 수신자.메시지이름(인자)
  - ex) 모자장수.증언하라(어제,왕국)
- 객체가 제공하는 '메시지'는 외부의 다른 객체가 볼 수 있는 공개개된 영역
- 메시지를 처리하기 위해 책임을 수행하는 '방법'은 외부 객체가 볼 수 없는 사적인 영역


### 2.2 메서드

- 메서드: 메시지를 처리하기 위해 내부적으로 선택하는 방법
- 메시지 수신 단계
    - 1단계: 처리할 수 있는가?
    - 2단계: 어떤 메시지를 처리할 방법으로 어떤 메서드를 사용할 것인가?
- 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 객체지향의 핵심적인 특징 중 하나다.


### 2.3 다형성

- 다형성: 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 성질.
- 구체적으로 말하자면, 서로 다른 타입에 속하는 객체들이 동일한 메시지(요청, 무엇, 송신자)를 받았을 경우에 서로 다른 메서드(방법, 어떻게, 수신자)를 이용해 메시지를 처리할 수 있는 메커니즘
- 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미함.


### 2.4 유연하고 확장 가능하고 재사용성이 높은 협력의 의미
- 송신자가 수신자에 대해 매우 적은 정보(=수신자가 메시지를 이해할 수 있다는 사실)만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.
- 첫째. 협력이 유연해진다.
  - 송신자는 수신자에 대해 어떠한 제한도 없기 때문에 대체하더라도 알지 못한다.
- 둘째. 협력이 수행되는 방식을 확장할 수 있다.
  - 송신자에게 아무런 양향도 미치지않고서도 수신자를 교체할 수 있기 때문에 세부적인 수행 방식을 쉽게 수정할 수 있다.
- 셋째. 협력이 수행되는 방식을 재사용할 수 있다.
  - 다양한 문맥에서 협력을 재사용할 수 있으니깐
  - 모자 장수가 존재하는 곳에서도, 요리사가 존재하는 곳에서도, 앨리스가 존재하는 곳에서도 등.

### 2.5 송신자와 수신자를 약하게 연결하는 메시지

- 수신자와 송신자는 메시지라는 얇은 끈으로만 연결되어있다.
- 메시지는 다형성 성질을 가져 유연하고 확장가능하고 재사용성이 높은 협력을 가능하게 해준다.


## 3.메시지를 따라라

### 3.1 객체지향의 핵심, 메시지

- 객체지향은 클래스가 아닌 객체들의 협력이 중심이어야 한다.
    - 클래스 중심 설계는 유연하지 않고 확장하기 어렵다.
    - 클래스는 단지 객체를 생성하고 코드 양을 줄여주는 역할.
    - 단순히 객체에 집중이 아니라 메시지를 주고 받는 객체의 협력이 중심이다.
    - 협력 --> 객체 --> 클래스 (데이터 주도 설계)
- 객체지향 설계의 중심에는 메시지가 있다.

### 3.2 책임-주도 설계 다시 살펴보기

- 책임을 완수하기 위해 자신이 보유하지 있지 않은 정보가 필요하면 다른 객체에게 메시지를 전송해 정보를 제공해 줄것을 요청해야 한다.
- 책임주도 설계: 책임을 완수하기 위해 협력하는 개체들을 이용해 시스템을 설계하는 방법

### 3.3 What/Who 사이클

- 책임주도 설계 방법: What/Who로 협력에 필요한 메시지를 **먼저** 결정한다.
  1. 어떤 행위(메시지)가 필요한가? - 메시지 결정
  2. 어떤 객체가 이 행위(메시지)를 수행할 것인가? - 객체 선택

- 결론을 말하자면 수신 가능한 메시지가 모여 인터페이스를 구성한다.

### 3.4 묻지 말고 시켜라

- 책임주도 설계는 객체 선택보다 메시지를 우선 선택한다.
- 그렇기 때문에 메시지 송신자는 수신할 객체 내부 상태를 보르게 되고
- 따라서 캡슐화에도 도움이 된다. 송신자가 수신자 내부 상태르 모르므로 느슨하게 결합된다.


### 3.5 메시지를 믿어라

- 객체의 구체적인 타입과 무관하게 전송된 메시지를 이해할 수 있는 개체들을 서로 연결하고 상호 협력가능하게 만드는 것은 유연학 재사용 가능한 설계의 기반이다.
- 그러니 메시지를 먼저 잘 만들면 자율적인 책임은 저절로 생긴다.

## 4.객체 인터페이스


### 4.1 인터페이스

- 인터페이스란 두 사물이 마주치는 경계에서 서로 상호작용할 수 있게 이어주는 방법이나 장치.
- 사람-사람(말과 글), 사람과스마트폰(손가락),사람-텔리비전(리모컨)
- 인터페이스 특징 3가지
  1. 사용법만 익히면 내부 동작 방식을 몰라도 사용할 수 있다.
  2. 내부 작동방식만 변경하는 것은 사용자에게 영향을 주지 않는다.
  3. 대상이 변경되더라도 동일한 인터페이스를 제공하면 문제없다.
- 인터페이스 특징 3가지 예시
  1. 자동차 원리를 몰라도 운전할 수 있다.
  2. 엔진을 교체하더라도 운전자에게는 상관없다
  3. 차를 k5에서 그랜저로 바꿔도 상관없다.

### 4.2 메시지가 인터페이스를 결정한다

- 메시지가 인터페이스를 만든다.

### 4.3 공용 인터페이스

- 외부에 공개된 인터펭스를 공용 인터페이스라고 한다.
- 인터페이스를 통해 메시지를 수신할 수 있다.
- 공용 인터페이스는 외부로부터 수신할 수 있는 메시지의 목록

### 4.4 책임, 메시지, 그리고 인터페이스



### 5.인터페이스와 구현의 분리

### 5.1 객체 관점에서 생각하는 방법

- 좀 더 객체지향적인 사고 방식을 하기 위한 3가지 원칙
    1. 좀 더 추상적인 인터페이스: 적절한 추상성이 자율성 보장
    2. 최소 인터페이스: 외부에 사용할 필요없는 인터페이스는 노출 자제
    3. 인터페이스와 구현 간에 차이가 있다는 점을 인식
        - 객체 외부 = 공용 인터페이스
        - 객체 내부 = 구현

### 5.2 구현

- 구현(Implementation)이란 내부 구조와 작동 방식을 가리키는 용어다.
- 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것.
  - 객체의 상태 구현
  - 객체의 행동(메서드) 구현
  - 이 부분은 수정하더라도 객체 외부에 영향이 있어선 안된다.

### 5.3 인터페이스와 구현의 분리 원칙

- 훌륭한 객체: 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체
- 왜 인터페이스와 구현을 분리하는 게 중요한가?
  - 소프트웨어하는 항상 변경되니깐 --> 모든 것이 공개되면 작게 수정하더라도 파급효과가 크다.
  - 변경을 관리하기 위해서.

### 5.4 캡슐화

- 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 캡슐화라 한다.
- 정보 은닉이라고도 한다.
- 2가지 관점이 있다.
  - 상태와 행위의 캡슐화(=데이터 캡슐화)
    - 인터페이스와 구현을 분리하기 위한 전제조건
  - 사적인 비밀의 캡슐화(=공용 인터페이스 사용)
    - 외부의 객체는 공용 인터페이스에만 의존하고 구현세부 사항에 대해서는 직접 의존해서는 안된다.

## 6.책임의 자율성이 협력의 품질을 결정한다.





